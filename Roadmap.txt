=== The Ouroboros Libraries Roadmap ===

This is a brief discussion on the direction of Ouroboros in the foreseeable 
future.


== oBase == 

This is where things that ought to be in C++ go such as POSIX elements, more 
robust string and memory parsing and simple ubiquitous file formats and types.


== oCore == 

This is where interfaces for basic/standard hardware exist, such as filesystem,
virtual paging memory allocator, cpu, etc.


== oSurface ==

Everything to work with textures and images and all the advanced formats 
supported by compute/GPU devices.


== oGUI ==

A dumping ground for all the Windows widgets needed during use of Ouroboros.
There isn't an intent to be another QT or WxWidgets, but there also isn't enough 
need for bringing in such large middlewares either, so leave stuff somewhat 
unapologetically Windows-specific and have it all in this one lib for GUI stuff.


== Computation (oHLSL, oCompute) ==

"Compute" is the modern encompassing term for throughput or stream computing. 
Sony Playstation 2 and 3 programmers will be familiar with the concept as it is 
fully separate from the GPU on those platforms. Basically stream computing is 
about a small algorithm and a whole lot of data being fed through that 
algorithm. It could be rasterization, raytracing, fourier transforms, protein 
folding, whatever - there's a lot of data to get through, though the algorithm 
once refined is relatively small.

The intent in Ouroboros is to make the stream programming model available 
everywhere as technologies emerge. HLSL, GLSL and OpenCL are all very similar 
and work on primitives that have grown out of their graphics hardware roots.

Eventually Ouroboros will create a cross-compute language layer that will allow 
with minor tweaks the compute APIs to be callable on CPU (and future Sony-style 
coprocessors) as well as specialized co-processors like GPUs. The oCompute 
layer is a collection of common algorithms written in that cross-compile 
language. It is unclear at this time whether oHLSL will evolve to be the cross-
platform thing with lots of #ifdefs or if there will be an oGLSL and oOpenGL 
layer with lots of duplicate declarations, but the idea is to assume compute 
primitives because in the author's opinion the union of the big three compute 
languages should be available (including 2-3-4 tuples, basic up-to 4x4 matrices 
and swizzle operations) as part of the C++ standard library. All 4 languages 
should also have native quaternion and simple volume types.


== oFramework ==

Does not exist yet. oFramework will be allowed to make more system-wide 
assumptions as it ties more building blocks together.

== Features ==

SDL and other "creative programming" starting libraries are missing 2 important 
things in my opinion and providiing something I don't want:
1. SDL provides a media window, but not a regular OS window for tools creation.
2. SDL does not have an asset paging/caching system.

If you called #1 HTML5 and #2 the file cache implemented in webkit/ browsers it 
becomes clear why browser-based technology is gaining popularity - someone 
solved the hard problems of cross-platform windowing, file I/O from any source 
and smart use of disk space for remote data. The intent of Ouroboros is to be 
similar to this, but to outpace HTML5/WebGL's slow pace due to massive cross-
platform compatibility requirements as well as large design-by-commitee 
standards boards.

The part of SDL and the like I don't want is that often these systems come with 
some trivial material system that often has a specular color and one texture. A 
lot of code is written around a material system that seems to me people will 
outgrow in the first month of bring-up.

For this reason, the main focus of the next year will be to enhance the oGfx 
layer with robust support for basic 3D graphics assets management. We expect to 
define an optimized binary format for:
1. simple/typical meshes
2. textures
3. user-definable materials

We will still be treating shaders as code for the foreseeable future, but the 
discussion about treating it more dynamically to enable fast-reload and 
iteration continues.

We also expect to define an XML-based scene file format for the development of 
simple scenes. Because of our video product UI scenes will be the first to get 
attention. So basically we're building a big sprite engine with attention 
towards moving to true 3D immediately afterwards.

That's as far into Ouroboros's future as I can see right now. If you have a 
project you'd like to build using Ouroboros and there are significant missing 
elements you'd like to see authored or wish to contribute yourself, please 
contact me at arciuolo@gmail.com.

Sincerely,
Tony
